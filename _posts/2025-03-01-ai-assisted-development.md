---
layout: post
title: "AI-Assisted Development: Building Projects with Claude and ChatGPT"
date: 2025-03-01 15:30:00 +0800
categories: [technology, ai]
tags: [ai, development, claude, chatgpt, coding]
image: /assets/images/ai-coding.png
excerpt: "During my recent projects, I've been experimenting extensively with AI tools like Claude and ChatGPT for code generation. Here's what I've learned about the strengths, limitations, and best practices for AI-assisted development."
---

During my recent projects, I've been experimenting extensively with AI tools like Claude and ChatGPT for code generation. Here's what I've learned about the strengths, limitations, and best practices for AI-assisted development. 

*NOTE: This post was generated with Claude, based on the totality of the project described earlier, [Building a Personal VPN Service with AWS, Terraform, and iOS](/projects/cloud/mobile/2025/02/18/building-personal-vpn-service.html)*

## The AI Development Workflow

My typical workflow now involves a collaborative process with AI:

1. **System Design**: I sketch out the high-level architecture and components
2. **Prompt Engineering**: I create detailed prompts for each component
3. **Code Generation**: The AI models generate initial code
4. **Review & Refinement**: I review, test, and refine the generated code
5. **Integration**: I integrate the components and ensure they work together

This approach has dramatically accelerated my development process, especially for projects with standard patterns and boilerplate code.

## AI Strengths in Development

After building several complete projects with AI assistance, I've found these tools excel at:

### 1. Boilerplate Code Generation

AI tools are exceptional at generating repetitive, structural code:

```swift
// Generated by Claude - A standard SwiftUI view with common patterns
struct ContentView: View {
    @StateObject private var viewModel = ViewModel()
    @State private var isLoading = false
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(viewModel.items) { item in
                    ItemRow(item: item)
                }
            }
            .navigationTitle("Items")
            .toolbar {
                Button("Add") {
                    viewModel.addItem()
                }
            }
            .overlay {
                if isLoading {
                    ProgressView()
                }
            }
        }
        .onAppear {
            loadData()
        }
    }
    
    private func loadData() {
        isLoading = true
        Task {
            await viewModel.fetchData()
            isLoading = false
        }
    }
}
```

### 2. Cross-Platform Knowledge

AI models know patterns across multiple languages and frameworks, making them valuable for full-stack development:

- Frontend (SwiftUI, React)
- Backend (Python, Node.js)
- Infrastructure (Terraform, CloudFormation)
- DevOps (GitHub Actions, CI/CD pipelines)

### 3. Documentation Generation

AI tools excel at creating clear documentation, including:
- README files
- API documentation
- System architecture diagrams
- User guides

## Limitations and Challenges

Despite their capabilities, I've encountered several limitations:

### 1. Architecture Decisions

AI tools often struggle with higher-level architectural decisions that require deep domain knowledge. For my VPN project, I needed to:

- Choose appropriate AWS service combinations
- Design the security model
- Plan for cost optimization

These decisions required human judgment based on experience.

### 2. Integration Complexities

When generating code for multiple components, I found AI tools sometimes created inconsistent interfaces. I needed to:

- Ensure data models matched across components
- Verify authentication flowed correctly
- Fix integration bugs between generated components

### 3. Edge Cases and Error Handling

Generated code often handles the happy path well but misses edge cases:

```python
# Original AI-generated code - missing error handling
def get_vpn_status(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    state = response["Reservations"][0]["Instances"][0]["State"]["Name"]
    return state

# After human refinement
def get_vpn_status(instance_id):
    try:
        response = ec2_client.describe_instances(InstanceIds=[instance_id])
        if not response["Reservations"]:
            return "unknown"
        state = response["Reservations"][0]["Instances"][0]["State"]["Name"]
        return state
    except Exception as e:
        logger.error(f"Error getting VPN status: {str(e)}")
        return "error"
```

## Best Practices for AI-Assisted Development

Through my experiments, I've developed these best practices:

### 1. Effective Prompt Engineering

The quality of generated code directly depends on prompt quality:

- **Be specific about requirements**: Include expected inputs, outputs, and behavior
- **Provide context**: Explain how the component fits into the larger system
- **Include example patterns**: Show similar code you like
- **Request explanations**: Ask the AI to explain its design decisions

The prompts used and responses given which produced project are published in the project repo: [TerrorTunnels: GenAI Chat Transcripts](https://github.com/TerrorTunnels/.github/blob/main/GenAI_chats/README.md)

### 2. Iterative Refinement

Treat AI-generated code as a first draft:

- Start with a basic implementation
- Test core functionality
- Identify gaps and issues
- Request specific improvements
- Gradually enhance with error handling, optimization, etc.

### 3. Human Review is Essential

Always review generated code for:

- Security vulnerabilities
- Performance issues
- Edge cases
- Maintainability
- Best practices

## Case Study: The VPN Control Project

For my VPN control project, I used AI for:

1. **Infrastructure**: Generated 90% of the Terraform code
2. **API Layer**: Complete Lambda function and API Gateway configuration
3. **iOS App**: Core UI components and network layer

However, I needed to manually:
- Configure security policies
- Optimize instance setup
- Fix edge cases in the state management
- Ensure secure key handling

## The Future of AI-Assisted Development

As AI tools continue to evolve, I see several trends emerging:

1. **More contextual awareness**: Better understanding of project structure
2. **Enhanced reasoning**: Improved architectural design capabilities
3. **Interactive development**: Real-time collaboration during coding
4. **Custom models**: Trained on specific codebases and patterns

## Conclusion

AI-assisted development has transformed my workflow and productivity. While these tools can't replace human judgment and experience, they dramatically accelerate the implementation process and handle routine aspects of development.

For developers looking to incorporate AI into their workflow, I recommend starting with smaller components, developing good prompt engineering skills, and maintaining a balance between AI assistance and human oversight.

Have you experimented with AI-assisted development? I'd love to hear about your experiences in the comments!
